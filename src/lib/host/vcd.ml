(** VCD output *)

type cfg = {
    mutable default_int_size: int;
    mutable float_precision: int;
  }

let cfg = {
    default_int_size = 8;
    float_precision = 8;
  }


module type VCD = sig
  type seq
  exception Unsupported of Vcd_types.vcd_typ * Vcd_types.vcd_value
  val output: fname:string -> seq -> unit
end

module Make (Seq: Seq.SEQ) : VCD with type seq = Seq.t =
struct

  type seq = Seq.t
  module Event = Seq.Evset.Event

  open Printf
 
  exception Unsupported of Vcd_types.vcd_typ * Vcd_types.vcd_value
     
  let vcd_kind_of ty =
    match ty with
    | Vcd_types.TyEvent -> "event", 1
    | Vcd_types.TyBool  -> "wire", 1
    | Vcd_types.TyInt (Some w) -> "wire", w
    | Vcd_types.TyInt None -> "wire", cfg.default_int_size
    | Vcd_types.TyString -> "real", 1

  let vcd_repr ty v = match ty, v with
  | Vcd_types.TyInt (Some w), Vcd_types.Val_int v -> Printf.sprintf "b%s" (Bits.of_int w v)
  | Vcd_types.TyInt None, Vcd_types.Val_int v -> Printf.sprintf "b%s" (Bits.of_int (cfg.default_int_size) v)
  | Vcd_types.TyBool, Vcd_types.Val_bool v -> Printf.sprintf "b%d" (if v then 1 else 0)
  | Vcd_types.TyString, Vcd_types.Val_string s -> Printf.sprintf "s%s" s
  | _, _ -> raise (Unsupported (ty,v))

  let register_event acc e =
    match e with
    | Event.Ev name -> Vcd_types.register_signal acc (name, Vcd_types.TyEvent)
    | Event.Upd (l,v) ->
       (* let name = Event.Syntax.vcd_name l in
        * Format.printf "** Registering lhs=%a under name %s\n" (Event.Syntax.pp_lhs ~with_type:false) l name; *)
       Vcd_types.register_signal acc (Event.Syntax.vcd_name l, Event.Value.vcd_type v)
    | Event.StateMove (s,q) -> Vcd_types.register_signal acc (s, Vcd_types.TyString)

  let register_signals acc (s:Seq.Evset.t) =
    List.fold_left register_event acc (Seq.Evset.events s)

  let dump_signal oc (name,(id,ty)) =
    let kind, size =  vcd_kind_of ty in
    fprintf oc "$var %s %d %c %s $end\n" kind size id name

  let dump_evseq oc signals s =
    let lookup name = 
      try List.assoc name signals
      with Not_found -> Misc.fatal_error ("Vcd.dump_evseq: unknown signal: " ^ name) in
    let dump_stimulus s = match s with
      | Event.Ev name ->
         let id, _  = lookup name in 
         fprintf oc "1%c\n" id          (* Instantaneous event *)
      | Event.Upd (l, v) ->             (* Update *)
         let name = Event.Syntax.vcd_name l in
         let id, ty  = lookup name in 
         let v' = Event.Value.vcd_value v in
         let fmt = vcd_repr ty v'  in
         fprintf oc "%s %c\n" fmt id
      | Event.StateMove (s,q) ->
         let id, ty  = lookup s in 
         fprintf oc "s%s %c\n" q id in  (* State move*)
    fprintf oc "#%d\n" (Seq.Evset.date s);
    List.iter dump_stimulus (Seq.Evset.events s) 
  
  let output ~fname (rs:Seq.t) =
    let oc = open_out fname in
    let signals = List.fold_left register_signals [] rs in
    fprintf oc "$date\n";
    fprintf oc "   %s\n" "today";
    fprintf oc "$end\n";
    (* fprintf oc "$version\n";
     * fprintf oc "   RFSM\n";
     * fprintf oc "$end\n"; *)
    fprintf oc "$comment\n";
    fprintf oc "   Generated by RFSM compiler (github.com/jserot/rfsm)\n";
    fprintf oc "$end\n";
    fprintf oc "$timescale 1ns $end\n";
    fprintf oc "$scope module top $end\n";
    List.iter (dump_signal oc) signals;
    fprintf oc "$upscope $end\n";
    fprintf oc "$enddefinitions\n$end\n";
    List.iter (dump_evseq oc signals) rs;
    close_out oc  
end
