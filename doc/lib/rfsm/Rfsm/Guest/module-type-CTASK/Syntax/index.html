<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Syntax (rfsm.Rfsm.Guest.CTASK.Syntax)</title><link rel="stylesheet" href="../../../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">rfsm</a> &#x00BB; <a href="../../../index.html">Rfsm</a> &#x00BB; <a href="../../index.html">Guest</a> &#x00BB; <a href="../index.html">CTASK</a> &#x00BB; Syntax</nav><header class="odoc-preamble"><h1>Module <code><span>CTASK.Syntax</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#type-expressions">Type expressions</a></li><li><a href="#type-declarations">Type declarations</a></li><li><a href="#expressions">Expressions</a></li><li><a href="#lhs">LHS</a></li><li><a href="#substitutions">Substitutions</a></li><li><a href="#pre-processing">Pre-processing</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Types"><a href="#module-Types" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Types/index.html">Types</a></span><span> : <a href="../../module-type-TYPES/index.html">TYPES</a></span></code></div></div><h4 id="type-expressions"><a href="#type-expressions" class="anchor"></a>Type expressions</h4><div class="odoc-spec"><div class="spec type anchored" id="type-type_expr"><a href="#type-type_expr" class="anchor"></a><code><span><span class="keyword">type</span> type_expr</span><span> = <span><span>(<a href="#type-type_expr_desc">type_expr_desc</a>, <a href="Types/index.html#type-typ">Types.typ</a>)</span> <a href="../../../Annot/index.html#type-t">Annot.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-type_expr_desc"><a href="#type-type_expr_desc" class="anchor"></a><code><span><span class="keyword">and</span> type_expr_desc</span></code></div><div class="spec-doc"><p>The type of guest-level <em>type expressions</em>, denoting types</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_bool_type"><a href="#val-is_bool_type" class="anchor"></a><code><span><span class="keyword">val</span> is_bool_type : <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_event_type"><a href="#val-is_event_type" class="anchor"></a><code><span><span class="keyword">val</span> is_event_type : <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_array_type"><a href="#val-is_array_type" class="anchor"></a><code><span><span class="keyword">val</span> is_array_type : <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_xxx_type te</code> should return <code>true</code> iff the type denoted by <code>te</code> is <code>xxx</code>. Returns <code>false</code> if the guest language has no such type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_type_expr"><a href="#val-pp_type_expr" class="anchor"></a><code><span><span class="keyword">val</span> pp_type_expr : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_type_expr fmt te</code> prints type expression <code>te</code> on formatter <code>fmt</code>.</p></div></div><h4 id="type-declarations"><a href="#type-declarations" class="anchor"></a>Type declarations</h4><div class="odoc-spec"><div class="spec type anchored" id="type-type_decl"><a href="#type-type_decl" class="anchor"></a><code><span><span class="keyword">type</span> type_decl</span><span> = <span><span>(<a href="#type-type_decl_desc">type_decl_desc</a>, <a href="Types/index.html#type-typ">Types.typ</a>)</span> <a href="../../../Annot/index.html#type-t">Annot.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-type_decl_desc"><a href="#type-type_decl_desc" class="anchor"></a><code><span><span class="keyword">and</span> type_decl_desc</span></code></div><div class="spec-doc"><p>The type of guest-level <em>type declarations</em> (ex: type aliases, records, ...)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_alias_type_decl"><a href="#val-mk_alias_type_decl" class="anchor"></a><code><span><span class="keyword">val</span> mk_alias_type_decl : <span><a href="../../../Ident/index.html#type-t">Ident.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-type_decl">type_decl</a></span></code></div><div class="spec-doc"><p><code>mk_alias_type_decl name te</code> should return an <em>alias</em> type declaration, <i>i.e.</i> the type declaration making <code>name</code> a synonym for <code>te</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_type_decl"><a href="#val-pp_type_decl" class="anchor"></a><code><span><span class="keyword">val</span> pp_type_decl : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-type_decl">type_decl</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_type_decl fmt td</code> prints type declaration <code>td</code> on formatter <code>fmt</code>.</p></div></div><h4 id="expressions"><a href="#expressions" class="anchor"></a>Expressions</h4><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = <span><span>(<a href="#type-expr_desc">expr_desc</a>, <a href="Types/index.html#type-typ">Types.typ</a>)</span> <a href="../../../Annot/index.html#type-t">Annot.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr_desc"><a href="#type-expr_desc" class="anchor"></a><code><span><span class="keyword">and</span> expr_desc</span></code></div><div class="spec-doc"><p>The type of guest-level <em>expressions</em></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vars_of_expr"><a href="#val-vars_of_expr" class="anchor"></a><code><span><span class="keyword">val</span> vars_of_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../Ident/index.html#type-t">Ident.t</a> list</span></span></code></div><div class="spec-doc"><p><code>vars_of_expr e</code> should return the list of variables occuring in expression <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_expr"><a href="#val-pp_expr" class="anchor"></a><code><span><span class="keyword">val</span> pp_expr : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_expr fmt e</code> prints expression <code>e</code> on formatter <code>fmt</code>.</p></div></div><h4 id="lhs"><a href="#lhs" class="anchor"></a>LHS</h4><div class="odoc-spec"><div class="spec type anchored" id="type-lhs_desc"><a href="#type-lhs_desc" class="anchor"></a><code><span><span class="keyword">type</span> lhs_desc</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lhs"><a href="#type-lhs" class="anchor"></a><code><span><span class="keyword">and</span> lhs</span><span> = <span><span>(<a href="#type-lhs_desc">lhs_desc</a>, <a href="Types/index.html#type-typ">Types.typ</a>)</span> <a href="../../../Annot/index.html#type-t">Annot.t</a></span></span></code></div><div class="spec-doc"><p>The type of <em>left-hand sides</em>, occuring at the left of the <code>:=</code> symbol in assignations. A guest language will typically have <em>variables</em> as LHS but can also support more elaborated forms, such as array indices (ex: <code>a[i]:=...</code>) or record fields (ex: <code>r.f := ...</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_simple_lhs"><a href="#val-mk_simple_lhs" class="anchor"></a><code><span><span class="keyword">val</span> mk_simple_lhs : <span><a href="../../../Ident/index.html#type-t">Ident.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lhs">lhs</a></span></code></div><div class="spec-doc"><p><code>mk_simple_lhs name</code> should return the LHS designating a simple variable with name <code>name</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_simple_lhs"><a href="#val-is_simple_lhs" class="anchor"></a><code><span><span class="keyword">val</span> is_simple_lhs : <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_simple_lhs l</code> should return <code>true</code> iff LHS <code>l</code> is a simple variable</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lhs_base_name"><a href="#val-lhs_base_name" class="anchor"></a><code><span><span class="keyword">val</span> lhs_base_name : <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../Ident/index.html#type-t">Ident.t</a></span></code></div><div class="spec-doc"><p><code>lhs_base_name l</code> should return the <em>base name</em> of LHS <code>l</code>. If <code>l</code> is a simple variable, this is simply its name. For array or record access, this will typically the name of target array (resp. record).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lhs_prefix"><a href="#val-lhs_prefix" class="anchor"></a><code><span><span class="keyword">val</span> lhs_prefix : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lhs">lhs</a></span></code></div><div class="spec-doc"><p><code>lhs_prefix p l</code> should return the LHS obtained by adding prefix <code>&quot;p.&quot;</code> to the base name of LHS <code>l</code>. For example, if <code>l</code> is a simple variable named <code>&quot;v&quot;</code>, <code>lhs_prefix &quot;foo&quot; l</code> is the <code>&quot;foo.v&quot;</code>. This function is used to generated <em>name scopes</em> when dumping VCD traces.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lhs_vcd_repr"><a href="#val-lhs_vcd_repr" class="anchor"></a><code><span><span class="keyword">val</span> lhs_vcd_repr : <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../Ident/index.html#type-t">Ident.t</a></span></code></div><div class="spec-doc"><p><code>lhs_vcd_repr l</code> should return a representation of LHS <code>l</code> to be used in a VCD trace file. If <code>l</code> is a simple variable, this is simply its name. Other cases will depend on the LHS definition and the version of VCD format used. See for example the definition of <code>lhs_vcd_repr</code> for the <code>full</code> guest language.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vars_of_lhs"><a href="#val-vars_of_lhs" class="anchor"></a><code><span><span class="keyword">val</span> vars_of_lhs : <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../Ident/index.html#type-t">Ident.t</a> list</span></span></code></div><div class="spec-doc"><p><code>vars_of_lhs l</code> should return the list of variables occuring in LHS <code>l</code>. This includes simple variables but also the name of the target array, record, etc.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_lhs"><a href="#val-pp_lhs" class="anchor"></a><code><span><span class="keyword">val</span> pp_lhs : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_lhs fmt l</code> prints LHS <code>l</code> on formatter <code>fmt</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_qual_lhs"><a href="#val-pp_qual_lhs" class="anchor"></a><code><span><span class="keyword">val</span> pp_qual_lhs : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <code>pp_lhs</code> but with an indication of the <a href="../../../Ident/index.html#type-scope"><code>Ident.scope</code></a> of the LHS</p></div></div><h4 id="substitutions"><a href="#substitutions" class="anchor"></a>Substitutions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-subst_expr"><a href="#val-subst_expr" class="anchor"></a><code><span><span class="keyword">val</span> subst_expr : <span><span><a href="../../../Ident/index.html#type-t">Ident.t</a> <a href="../../../Subst/index.html#type-t">Subst.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expr">expr</a></span></code></div><div class="spec-doc"><p><code>subst_id phi e</code> applies substitution <code>phi</code> to expression <code>e</code>, substituting each occurrence of identifier <code>id</code> by identifier <code>phi id</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst_lhs"><a href="#val-subst_lhs" class="anchor"></a><code><span><span class="keyword">val</span> subst_lhs : <span><span><a href="../../../Ident/index.html#type-t">Ident.t</a> <a href="../../../Subst/index.html#type-t">Subst.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lhs">lhs</a></span></code></div><div class="spec-doc"><p><code>subst_lhs phi l</code> applies substitution <code>phi</code> to LHS <code>l</code>, substituting each occurrence of identifier <code>id</code> by identifier <code>phi id</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst_param_type_expr"><a href="#val-subst_param_type_expr" class="anchor"></a><code><span><span class="keyword">val</span> subst_param_type_expr : <span><span><a href="#type-expr">expr</a> <a href="../../../Subst/index.html#type-t">Subst.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-type_expr">type_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-type_expr">type_expr</a></span></code></div><div class="spec-doc"><p><code>subst_type_expr phi te</code> applies substitution <code>phi</code> to type_expression <code>te</code>, replacing all occurences of <em>parameter</em> name <code>id</code> in type expression <code>te</code> by <code>phi id</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst_param_expr"><a href="#val-subst_param_expr" class="anchor"></a><code><span><span class="keyword">val</span> subst_param_expr : <span><span><a href="#type-expr">expr</a> <a href="../../../Subst/index.html#type-t">Subst.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expr">expr</a></span></code></div><div class="spec-doc"><p><code>subst_expr phi e</code> applies substitution <code>phi</code> to expression <code>e</code>, substituting each occurrence of <em>parameter</em> name <code>id</code> by expression <code>phi id</code></p></div></div><h4 id="pre-processing"><a href="#pre-processing" class="anchor"></a>Pre-processing</h4><div class="odoc-spec"><div class="spec type anchored" id="type-ppr_env"><a href="#type-ppr_env" class="anchor"></a><code><span><span class="keyword">type</span> ppr_env</span><span> = <span><a href="#type-type_expr">type_expr</a> <a href="../../../Env/index.html#type-t">Env.t</a></span></span></code></div><div class="spec-doc"><p>Since pre-processing takes place at the syntax level, before typing, type information has to be provided explicitely by mapping identifiers to type expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ppr_expr"><a href="#val-ppr_expr" class="anchor"></a><code><span><span class="keyword">val</span> ppr_expr : <span><a href="#type-ppr_env">ppr_env</a> <span class="arrow">&#45;&gt;</span></span> <span>?expected_type:<span><a href="#type-type_expr">type_expr</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expr">expr</a></span></code></div><div class="spec-doc"><p><code>ppr_expr env e</code> should return the result of pre-processing expression <code>e</code> in env <code>env</code>. The optional argument <code>expected_type</code> can be used to perform type-dependent transformations. A typical usage is to rewrite <code>0</code> (resp <code>1</code>) as <code>false</code> (resp. <code>true</code>). See <code>guests/core/lib/syntax.ml</code> for example</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ppr_lhs"><a href="#val-ppr_lhs" class="anchor"></a><code><span><span class="keyword">val</span> ppr_lhs : <span><a href="#type-ppr_env">ppr_env</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lhs">lhs</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lhs">lhs</a></span></code></div><div class="spec-doc"><p><code>ppr_lhs env e</code> should return the result of pre-processing LHS <code>e</code> in env <code>env</code>.</p></div></div></div></body></html>