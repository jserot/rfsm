# Synchronisation de trois automates par un protocole de type handshake
#
#  +---------+              +----------+              +----------+
#  |         |    r_rdy1    |          |    r_rdy2    |          |
#  |         |<-------------|          |<-------------|          |
#  |         |      V1      |          |      V2      |          |
#  |         |      –       |          |      –       |          |
#  | Emitter |----->|------>|  Interm  |----->|------>| Receiver |
#  |         |      –       |          |      –       |          |
#  |         |    e_rdy1    |          |    e_rdy2    |          |
#  |         |------------->|          |------------->|          |
#  |         |              |          |              |          |
#  +---------+              +----------+              +----------+

type t_data = int # Par ex

fsm model Emetteur(
     in h: event,
     in r_rdy: bool,
     out data: t_data,
     out e_rdy: bool)
  {
  states: E1, E2;
  vars:
    cnt: int;
  trans:
    E1 -- h.r_rdy=1 | data:=cnt; cnt:=cnt+1; e_rdy:=1 -> E2,
    E2 -- h.r_rdy=0 | e_rdy:=0 -> E1;
  itrans: | e_rdy:=0; cnt:=1 -> E1;
  }

fsm model Recepteur(
     in h: event,
     in e_rdy: bool,
     in data: t_data,
     out r_rdy: bool,
     out dout: t_data)
  {
  states: R1, R2;
  vars: t: int;
  trans:
    R1 -- h.e_rdy=1 | dout:=data; r_rdy:=0 -> R2,
    R2 -- h.e_rdy=0 | r_rdy:=1 -> R1;
  itrans: | r_rdy:=1 -> R1;
  }

fsm model Interm<delai:int>(
# [delai] est le nombre de tops de [h] requis pour produire la sortie [dout]
#  une fois recue l'entree [din]
     in h: event,
     in e_rdy1: bool,
     in din: t_data,
     out r_rdy1: bool,
     in r_rdy2: bool,
     out dout: t_data,
     out e_rdy2: bool)
  {
  states: R1, R2, U, E1, E2;
  vars:
    data: t_data,
    t: int;
  trans:
    R1 -- h.e_rdy1=1 | data:=din; r_rdy1:=0 -> R2,
    R2 -- h.e_rdy1=0 | r_rdy1:=1; t:=0 -> U,
     U -- h.t<delai | t:=t+1 -> U,
     U -- h.t=delai -> E1,
    E1 -- h.r_rdy2=1 | dout:=data; e_rdy2:=1 -> E2,
    E2 -- h.r_rdy2=0 | e_rdy2:=0 -> R1;
  itrans: | r_rdy1:=1; e_rdy2:=0 -> R1;
  }

input H:event = periodic(10,10,800)

shared e_rdy1, r_rdy1: bool
shared e_rdy2, r_rdy2: bool
shared v1, v2:t_data

output r_data: t_data

fsm e = Emetteur(H,r_rdy1,v1,e_rdy1)
fsm i = Interm<5>(H,e_rdy1,v1,r_rdy1,r_rdy2,v2,e_rdy2)
fsm r = Recepteur(H,e_rdy2,v2,r_rdy2,r_data)
