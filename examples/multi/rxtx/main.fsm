# TX -> RX (1 start bit, LSB->MSB, no parity bit, 1 stop bit)

type bit = int<1>

fsm model Txd<n:int> ( # n gives the bit duration (in clk periods)
     in clk: event,
     in din: int<8>,
     in wr: bool,
     out sout: bit)
  {
  states: Idle, Start, Tx, Parity, Stop;
  vars:
    i: int<0:8>,
    k: int<0:n>,
    r: int<8>,
    p: int<4>;
  trans:
    Idle -- clk.wr=0 -> Idle,
    Idle -- clk.wr=1 | r:=din; sout:=0; k:=0 -> Start,
    Start -- clk.k<n-1 | k:=k+1; p:=0 -> Start,
    Start -- clk.k=n-1 | k:=0; i:=1; sout:=r[0]; p:=p+r[0] -> Tx,
    Tx -- clk.k<n-1 | k:=k+1 -> Tx,
    Tx -- clk.(k=n-1).(i<8) | sout:=r[i]; p:=p+r[i]; i:=i+1; k:=0 -> Tx,
    Tx -- clk.(k=n-1).(i=8) | sout:=p[0]; k:=0 -> Parity,
    Parity -- clk.(k<n-1) | k:=k+1 -> Parity,
    Parity -- clk.(k=n-1) | sout:=1; k:=0 -> Stop,
    Stop -- clk.(k<n-1) | k:=k+1 -> Stop,
    Stop -- clk.(k=n-1) -> Idle;
  itrans: | sout:=1 -> Idle;
  }

fsm model Rxd<n:int> ( # n gives the bit duration (in clk periods)
     in clk: event,
     in sin: bit,
    out dout: int<8>,
    out err: bool)
  {
  states: Idle, Sync, Rx ;
  vars:
    i: int<0:8>,
    k: int<0:n>,
    r: int<8>,
    p: int<4>;
  trans:
    Idle -- clk.sin=0 | r:=0; k:=0 -> Sync,
    Sync -- clk.k<n/2-1 | k:=k+1 -> Sync,
    Sync -- clk.k=n/2-1 | k:=0; i:=0; p:=0 -> Rx,
    Rx -- clk.k<n-1 | k:=k+1 -> Rx,
    Rx -- clk.(k=n-1).(i<8) | r[i]:=sin; p:=p+sin; k:=0; i:=i+1 -> Rx,
    Rx -- clk.(k=n-1).(i=8) | err:=sin=p[0]?0:1; dout:=r -> Idle;
  itrans: -> Idle;
  }

input clk:event = periodic(10,10,550)
input din:int<8> = value_changes(10:69)  # 0x45
input wr:bool = value_changes(0:0, 15:1, 25:0)

shared serial:bit

output dout: int<8>  # should recover din value here !
output err: bool

fsm txd = Txd<4>(clk,din,wr,serial)
fsm rxd = Rxd<4>(clk,serial,dout,err)
