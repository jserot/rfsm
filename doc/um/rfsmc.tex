\chapter{Using the RFSM compiler}
\label{cha:rfsmc}

The RFSM compiler can be used to
\begin{itemize}
\item produce graphical representations of programs (using the \verb|.dot| format),
\item simulate programs, generating execution traces (\verb|.vcd| format),
\item generate C, SystemC or VHDL code from programs.
\end{itemize}

This chapter describes how to invoke compiler on the command-line. On Unix systems, this is
done from a terminal running a shell interpreter. On Windows, from an MSYS or Cygwin
terminal.

\medskip
The compiler is invoked with a command like :

\begin{FVerbatim}
rfsmc [options] file
\end{FVerbatim}

where \texttt{file} is the name of the file containing the source code (by convention, this file
should be suffixed \texttt{.fsm}). 

The complete set of options is described in App.~\ref{cha:compiler-options}.

The set of generated files depends on the selected target. The output file \texttt{rfsm.output}
contains the list of the generated file.

\section{Generating a graphical representation of the program}
\label{sec:gener-graph-repr}

\begin{FVerbatim}
rfsmc -dot foo.fsm  
\end{FVerbatim}

The previous command generates graphical representations of the program contained in file
\texttt{foo.cph} in \verb|.dot| format.  This representation can be viewed with the
\texttt{Graphviz} suite of tools\footnote{Available freely from \texttt{http://www.graphviz.org}.}.

By default, the command generates a single file
\verb|foo_top.dot| containing the top level representation of the system (with one
  ``box'' for each FSM instance). By passing the \verb|-dot_fsm_insts| option
  (resp. \verb|-dot_fsm_models|), it is possible to obtain separate \verb|.dot| files for each FSM
  instance (resp. model).

\section{Running the simulator}
\label{sec:running-simulator}

\begin{FVerbatim}
rfsmc -sim foo.fsm  
\end{FVerbatim}

The previous command runs simulator on the program contained in file \texttt{foo.fsm}, writing
an execution trace in VCD (Value Change Dump) format in file \verb|run.vcd|.

This \verb|.vcd| file can be viewed using a VCD visualizing application such as
\verb|gtkwave|\footnote{gtkwave.sourceforge.net}.

The name of the \verb|vcd.file| can be changed using the \verb|-vcd| option.

\section{Generating C code}
\label{sec:gener-c-code}

\begin{FVerbatim}
rsfmc -ctask foo.fsm  
\end{FVerbatim}

For each FSM instance \verb|f| contained in file \verb|foo.fsm|, the previous command generates a file
\verb|f.c| containing a C-based implementation of the corresponding behavior.

By default, the generated code is written in the current directory. This can be changed with the
\verb|-target_dir| option.

\section{Generating SystemC code}
\label{sec:gener-syst-code}

The minimal command for invoking the SystemC backend is :

\begin{FVerbatim}
rsfmc -systemc foo.fsm  
\end{FVerbatim}

This will  generate the SystemC code corresponding the program contained in file
\texttt{foo.fsm}, \emph{i.e.} write the following files :
\begin{itemize}
\item for each FSM instance \verb|f|, a pair of files \verb|f.h| and \verb|f.cpp| containing the
  interface and implementation of the SystemC module describing this instance,
\item for each input \verb|i|, a pair of files \verb|inp_i.h| and \verb|inp_i.cpp| containing the
  interface and implementation of the SystemC module describing this input (generating the
  associated stimuli, in particular),
\item a file \verb|tb.cpp| containing the description of the \emph{testbench} corresponding to the
  program for simulation.
\end{itemize}

Simulation itself is performed by compiling the generated code and running the executable,
using the standard SystemC toolchain.
In order to simplify this, the RFSM compiler also generates a list of \emph{Makefile} targets to be
appended to a predefined \emph{Makefile} so that compiling and running the code generated by the
SystemC backend can be performed by simply invoking \verb|make| on this \emph{Makefile}. For this,
the RFSM compiler simply needs to know where this predefined \emph{Makefile} has been
installed. This is achieved by using the \verb|-lib| option when invoking the compiler. For example,
provided that RFSM has been installed in directory \verb|/usr/local/rfsm|, the following command

\begin{FVerbatim}
rsfmc -systemc -lib /usr/local/rfsm/lib -target_dir ./systemc  foo.fsm  
\end{FVerbatim}

will write in directory \verb|./systemc| the generated source files and the corresponding
\verb|Makefile|. Compiling these files and running the resulting application is then simply achieved
by typing

\begin{verbatim}
cd ./systemc
make 
\end{verbatim}

\medskip
\textbf{Note}. Of course, you may have to adjust some definitions in the file
\verb|.../lib/etc/Makefile.systemc| to reflect the specifities of your local SystemC installation. 

\section{Generating VHDL code}
\label{sec:generating-vhdl-code}

The minimal command for invoking the VHDL backend is :

\begin{FVerbatim}
rsfmc -vhdl foo.fsm  
\end{FVerbatim}

This will  generate the VHDL code corresponding the program contained in file
\texttt{foo.fsm}, \emph{i.e.} write the following files :

\begin{itemize}
\item for each FSM instance \verb|f|, a file \verb|f.vhd| containing the
  entity and architecture describing this instance,
\item a file \verb|tb.vhd| containing the description of the \emph{testbench} corresponding to the
  program for simulation.
\end{itemize}

The produced files can then compiled, simulated and synthetized using a standard VHDL
toolchain\footnote{We use GHDL for simulation and Altera/Quartus for synthesis.}.

Concerning simulation, and as for the SystemC backend, the process can be grealy simplified by using
a pair of \emph{Makefile}s, one predefined and the other generated by the compiler.  For example,
and, again, provided that RFSM has been installed in directory \verb|/usr/local/rfsm|, the following
command

\begin{FVerbatim}
rsfmc -vhdl -lib /usr/local/rfsm/lib -target_dir ./vhdl  foo.fsm  
\end{FVerbatim}

will write in directory \verb|./vhdl| the generated source files and the corresponding
\verb|Makefile|. Compiling these files and running the resulting application is then simply achieved
by typing

\begin{verbatim}
cd ./vhdl
make 
\end{verbatim}

\medskip
\textbf{Note}. As for the SystemC backend, for this to work, you may have to adjust some definitions in the file

\section{Using \texttt{make}}
\label{sec:makefile}

The current distribution provides, in \verb|.../lib/etc| directory, a file \verb|Makefile.app|
aiming at easing the invokation of the RFSM compiler and the exploitation of the generated
products.

Basically, if this file has been installed, let say in directory \verb|/usr/local/rfsm/lib/etc|
and if you create the following Makefile in the working directory (that containing the RFSM source
file)

\begin{lstlisting}[language=make,frame=single]
APP= # to be set to the name of the source file (ex: foo)
DOT_OPTS= # to be adjusted if necessary
SIM_OPTS= # to be adjusted if necessary
SYSTEMC_OPTS= # to be adjusted if necessary
VHDL_OPTS= # to be adjusted if necessary
include /usr/local/rfsm/lib/etc/Makefile.app
\end{lstlisting}

then, for example, simply typing\footnote{Please refer to the file \texttt{Makefile.app} itself for
  a complete list of targets.}
  \begin{itemize}
  \item \verb|make dot| will generate the \verb|.dot| and lauch the corresponding viewer,
  \item \verb|make sim.run| to run the simulation using the interpreter (\verb|make sim.show| to display results),
  \item \verb|make ctask.code| will invoke the C backend C and generate the corresponding code,
  \item \verb|make systemc.code| will invoke the SystemC backend  and generate the corresponding code,
  \item \verb|make systemc.run| will invoke the SystemC backend, generate the corresponding
    code, compile it and run the corresponding simulation,
  \item \verb|make vhdl.code| will invoke the VHDL backend  and generate the corresponding code,
  \item \verb|make vhdl.run| will invoke the VHDL backend, generate the corresponding
    code, compile it and run the corresponding simulation,
  \item \verb|make sim.show| (resp \verb|make systemc.show| and \verb|make vhdl.show|) will display
    the simulation traces generated by the interpreter (resp. SystemC and VHDL simulation).
  \end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rfsm"
%%% End: 
