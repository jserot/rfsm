\chapter{Using the RFSM compiler}
\label{cha:rfsmc}

The RFSM compiler can be used to
\begin{itemize}
\item produce graphical representations of FSM models and programs (using the \verb|.dot| format),
\item simulate programs, generating execution traces (\verb|.vcd| format),
\item generate C, SystemC or VHDL code from FSM models and programs.
\end{itemize}

This chapter describes how to invoke compiler on the command-line. On Unix systems, this is
done from a terminal running a shell interpreter. On Windows, from an MSYS or Cygwin
terminal.

\medskip
The compiler is invoked with a command like :

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc [options] file\textsubscript{1} ... file\textsubscript{n}
\end{FVerbatim}

where \texttt{file\_1}, \ldots, \texttt{file\_n} are the names of files\footnote{By convention,
  these file names should have suffix \texttt{.fsm}.} containing source code.

\medskip
If the \verb|-c| option appears in the list of options, the given source files are assumed to
contain global types, global constants and FSM models. Each FSM model is then compiled 
and the corresponding code is produced, depending on the invoked backend (DOT, C, SystemC or VHDL). 

\medskip
Without the \verb|-c| option, the last source file (\verb|file_n|) is assumed to contain a
\emph{testbench} description, instantiating the previously defined FSM models on global inputs,
outputs or shared objects. The compiler then also produces code for the corresponding
\emph{testbench}, which can be used for simulating the corresponding program. 

\medskip
The complete set of options is described in App.~\ref{cha:compiler-options}.

\medskip
The set of generated files depends on the selected target. The output file \texttt{rfsm.output}
contains the list of the generated file.

\clearpage
\section{Generating a graphical representation of the program}
\label{sec:gener-graph-repr}

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc [-c] -dot f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

With the \verb|-c| option, the previous command generates graphical representations,in \verb|.dot| format, of each FSM model
contained in file \ifname{f}{1}{.fsm}, \ldots, \ifname{f}{n}{.fsm}. These representations can be viewed
with the \texttt{Graphviz} suite of tools\footnote{Available freely from
  \texttt{http://www.graphviz.org}.}.

Without the \verb|-c| option, and assuming file \ifname{f}{n}{.fsm} contains a \emph{testbench}
description -- \ie a set of FSM instanciations on global IOs and shared objects --, the 
command also generates a \verb|.dot| representation of the system top level in file
\ifname{f}{n}{dot}.

\section{Running the simulator}
\label{sec:running-simulator}

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc -sim f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

The previous command runs simulator on the program described in files \ifname{f}{1}{.fsm}, \ldots,
\ifname{f}{n}{.fsm}, writing
an execution trace in VCD (Value Change Dump) format in file \verb|run.vcd|.

The file \ifname{f}{n}{.fsm} is assumed to contain a valid \emph{testbench} description.

The \verb|-sim| and \verb|-c| options are incompatible.

This \verb|.vcd| file can be viewed using a VCD visualizing application such as
\verb|gtkwave|\footnote{gtkwave.sourceforge.net}.

The name of the \verb|vcd.file| can be changed using the \verb|-vcd| option.

\section{Generating C code}
\label{sec:gener-c-code}

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc -c -ctask f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

For each FSM model \verb|m| contained in file \ifname{f}{i}{.fsm}, the previous command generates a file
\verb|m.c| containing a C-based implementation of the corresponding behavior.

By default, the generated code is written in the current directory. This can be changed with the
\verb|-target_dir| option.

\section{Generating SystemC code}
\label{sec:gener-syst-code}

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc -c -systemc f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

For each FSM model \texttt{m} contained in files \ifname{f}{1}{.fsm}, \ldots, \ifname{f}{n}{.fsm},
the previous command will generate a pair of files \verb|m.h| and \verb|m.cpp| containing the
  interface and implementation of the SystemC module describing this model.

By default, the generated code is written in the current directory. This can be changed with the
\verb|-target_dir| option.

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc -systemc f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

Assuming file \ifname{f}{n}{.fsm} contains a \emph{testbench} description, the previous command will
also generate  
\begin{itemize}
\item for each global input \verb|i| defined in the \emph{testbench}, a pair of files \verb|inp_i.h|
  and \verb|inp_i.cpp| containing the interface and implementation of the SystemC module describing
  this input (generating the associated stimuli, in particular),
\item a file \ifname{f}{n}{cpp} containing the description of the \emph{testbench} corresponding to the
  program for simulation.
\end{itemize}

\medskip
Simulation itself is performed by compiling the generated code and running the executable,
using the standard SystemC toolchain.
In order to simplify this, the RFSM compiler also generates a list of \emph{Makefile} targets to be
appended to a predefined \emph{Makefile} so that compiling and running the code generated by the
SystemC backend can be performed by simply invoking \verb|make| on this \emph{Makefile}. For this,
the RFSM compiler simply needs to know where this predefined \emph{Makefile} has been
installed. This is achieved by using the \verb|-lib| option when invoking the compiler. For example,
provided that RFSM has been installed in directory \verb|/usr/local/rfsm|, the following command

\begin{FVerbatim}[commandchars=\\\{\}]
rsfmc -systemc -lib /usr/local/rfsm/lib -target_dir ./systemc f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

will write in directory \verb|./systemc| the generated source files and the corresponding
\verb|Makefile|. Compiling these files and running the resulting application is then simply achieved
by typing

\begin{verbatim}
cd ./systemc
make 
\end{verbatim}

\medskip
\textbf{Note}. Of course, you may have to adjust some definitions in the file
\verb|.../lib/etc/Makefile.systemc| to reflect the specificities of your local SystemC installation. 

\section{Generating VHDL code}
\label{sec:generating-vhdl-code}

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc -c -vhdl f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

For each FSM model \texttt{m} contained in files \ifname{f}{1}{.fsm}, \ldots, \ifname{f}{n}{.fsm}, the
previous command will generate a file \verb|m.vhd| containing the entity and architecture describing
this model.

By default, the generated code is written in the current directory. This can be changed with the
\verb|-target_dir| option.

\begin{FVerbatim}[commandchars=\\\{\}]
rfsmc -vhdl f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

Assuming file \ifname{f}{n}{.fsm} contains a \emph{testbench} description, the previous command will
also generate  
\begin{itemize}
\item a file \ifname{f}{n}{\_top.vhd} containing the description of the \emph{top level} model of the
  system,
\item a file \ifname{f}{n}{\_tb.vhd} containing the description of the \emph{testbench} for
  simulating the system.
\end{itemize}

The produced files can then compiled, simulated and synthetized using a standard VHDL
toolchain\footnote{We use GHDL for simulation and Altera/Quartus for synthesis.}.

Concerning simulation, and as for the SystemC backend, the process can be grealy simplified by using
a pair of \emph{Makefile}s, one predefined and the other generated by the compiler.  For example,
and, again, provided that RFSM has been installed in directory \verb|/usr/local/rfsm|, the following
command

\begin{FVerbatim}[commandchars=\\\{\}]
rsfmc -vhdl -lib /usr/local/rfsm/lib -target_dir ./vhdl f\textsubscript{1}.fsm ... f\textsubscript{n}.fsm
\end{FVerbatim}

will write in directory \verb|./vhdl| the generated source files and the corresponding
\verb|Makefile|. Compiling these files and running the resulting application is then simply achieved
by typing

\begin{verbatim}
cd ./vhdl
make 
\end{verbatim}

\medskip
\textbf{Note}. As for the SystemC backend, for this to work, you may have to adjust some definitions in the file

\section{Using \texttt{make}}
\label{sec:makefile}

The current distribution provides, in \verb|.../lib/etc| directory, a file \verb|Makefile.app|
aiming at easing the invokation of the RFSM compiler and the exploitation of the generated
products.

Suppose, for instance, that RFSM has been installed in \verb|/usr/local/rfsm| and the application is
to be compiled is made of two source files, \verb|foo.fsm|, containing the FSM model(s), and
\verb|main.fsm|, containing the global declarations and FSM instanciations (the so-called
\emph{testbench}). The only thing to do is create the following Makefile in the working directory
(that containing the RFSM source file)

\begin{lstlisting}[language=make,frame=single]
TB=main
SRCS=foo.fsm main.fsm
DOT_OPTS= ...
SIM_OPTS= ...
SYSTEMC_OPTS= ...
VHDL_OPTS= ...
include /usr/local/rfsm/lib/etc/Makefile.app
\end{lstlisting}

Then, simply typing\footnote{Please refer to the file \texttt{Makefile.app} itself for
  a complete list of targets.}
  \begin{itemize}
  \item \verb|make dot| will generate the \verb|.dot| and lauch the corresponding viewer,
  \item \verb|make sim.run| to run the simulation using the interpreter (\verb|make sim.show| to display results),
  \item \verb|make ctask.code| will invoke the C backend C and generate the corresponding code,
  \item \verb|make systemc.code| will invoke the SystemC backend  and generate the corresponding code,
  \item \verb|make systemc.run| will invoke the SystemC backend, generate the corresponding
    code, compile it and run the corresponding simulation,
  \item \verb|make vhdl.code| will invoke the VHDL backend  and generate the corresponding code,
  \item \verb|make vhdl.run| will invoke the VHDL backend, generate the corresponding
    code, compile it and run the corresponding simulation,
  \item \verb|make sim.show| (resp \verb|make systemc.show| and \verb|make vhdl.show|) will display
    the simulation traces generated by the interpreter (resp. SystemC and VHDL simulation).
  \end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rfsm"
%%% End: 
